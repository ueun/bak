ES6新增了哪些特性，使用过哪些，也有当场看代码说输出结果的

### ES6 Modules
- ES6 Modules之前，也有一些模块化方案，最主要的有CommonJS和AMD两种，前者用于服务器，后者用于浏览器
- 每一个模块实际只会加载一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象；
- 每个模块都有自己的上下文环境，每一个模块内声明的变量都是局部变量，不会污染全局作用域；
- 模块内部的变量或者函数可以通过export导出；
- 一个模块可以导入别的模块
- 自动开启严格模式，即使你没有写 use strict

### ES6中的extends关键字
- extends是个语法糖，背后做的工作本质还是原型链
- _classCallCheck —— 防止class被直接调用
- _createClass —— 将方法绑定原型上
- _inherits —— 继承函数，设置原型链
- _possibleConstructorReturn —— 调用父类构造函数进行父类属性的继承
- _get —— 子类通过super调用父类方法时，沿着原型链向上寻找直到找到该“继承”而来的方法

### Let + Const
const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性
所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义
反之就 let 而言，他的使用场景应该是相对较少的，我们只会在loop(for,while循环)及少量必须重定义的变量上用到他

### 增强的对象字面量

### 箭头函数
箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级

### Destructuring（解构）

### Rest + Spread
主要是应用 ... 运算符，完成值的聚合和分解

### Classes
ES6中实现的一个语法糖，用于简化基于原型集成实现类定义的场景
- 静态变量 static get

### Promises
- Promise则是把类似的异步处理对象和处理规则进行规范化， 并按照采用统一的接口来编写


### async、await
async函数其实就相当于funciton *的作用，而await就相当与yield的作用,比起Generator函数,async/await的语义更好，代码写起来更加自然。将异步处理的逻辑放在语法层面去处理，写的代码也更加符合人的自然思考方式。
